options{  STATIC = false;  LOOKAHEAD= 2;  DEBUG_PARSER = false;}PARSER_BEGIN(FormulaEvaluator)package br.cefetrj.parser;import java.io.StringReader;import java.io.Reader;import java.io.ByteArrayInputStream;public class FormulaEvaluator{  /*    ** A String based constructor for ease of use.  */  public FormulaEvaluator(String s)  {    this ((Reader) (new StringReader(s)));  }  public void parse() throws Exception  {    this.evaluate();  }  public double evaluate() throws Exception  {    return this.eval();  }  public static void main(String args []) throws ParseException  {    FormulaEvaluator parser = new FormulaEvaluator(System.in);    while (true)    {      System.out.println("Reading from standard input...");      System.out.print("Enter an expression like \"1+(2+3)*4\" :");      try      {        System.out.println(parser.eval());      }      catch (br.cefetrj.parser.ParseException e)      {        e.printStackTrace();        System.out.println("NOK.");        System.out.println(e.getMessage());        parser.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(FormulaEvaluator)SKIP :{  " "| "\t"| "\r"}TOKEN :{  < NUMBER_OF_VERTICES : "n" >}TOKEN :{  < NUMBER_OF_EDGES : "m" >}TOKEN :{  < EIGENVALUE_IDENTIFIER :   "q_n"  | "q_{n-1}"  | "\\lambda_n"  | "\\lambda_{n-1}"  | "\\mu_n"  | "\\mu_{n-1}"  | "q_" < DIGITS >  | "\\lambda_" < DIGITS >  | "\\mu_" < DIGITS >>}TOKEN :{  < IDENTIFIER_WITH_OVERLINE :    "\\overline{" < EIGENVALUE_IDENTIFIER > "}"  | "\\overline{" < CHROMATIC_NUMBER > "}"  | "\\overline{" < LARGEST_CLIQUE_SIZE > "}"  >}TOKEN :{  < EULER_CONSTANT :    "\\exp"  >}TOKEN :{  < CHROMATIC_NUMBER :    "\\chi"  >}TOKEN :{  < LARGEST_CLIQUE_SIZE :    "\\omega"  >}TOKEN :{  < LARGEST_DEGREE_IDENTIFIER :    "d_" < DIGITS >  >}TOKEN : /* Numeric constants */{  < INT_CONST : < DIGITS >>| < DBL_CONST :    < DIGITS > "." (< DIGIT >)* (< EXPONENT >)?  | "." < DIGITS > (< EXPONENT >)?  | < DIGITS > < EXPONENT >>| < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? < DIGITS >>}TOKEN : /* Helpers */{  < #DIGITS : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}TOKEN :{  < EOL : "\n" >}TOKEN :{  < PLUS : "+" >}TOKEN :{  < MINUS : "-" >}TOKEN :{  < POWER : "^" >}double eval() :{  double value;}{  value = expr()  (    < EOF >  | < EOL >  )  {    return value;  }}double expr() :{  double x;  double y;}{  x = term()  (    < PLUS > y = term()    {      x += y;    }  | < MINUS > y = term()    {      x -= y;    }  )*  {    return x;  }}double term() :{  double x;  double y;}{  x = expExpr()  (    "*" y = expExpr()    {      x *= y;    }  | "/" y = expExpr()    {      x /= y;    }  )*  {    return x;  }| "\\frac{" x = expr() "}" "{" y = expr() "}"  {    return x / y;  }}double expExpr() :{  double x;  double y;}{  x = value()  (    < POWER > y = value()    {      return Math.pow(x, y);    }  )?  {    return x;  }}double value() :{  double value;}{  "-" value = number()  {    return - value;  }| value = number()  {    return value;  }}double number() :{  Token t;  double value;}{  t = < EULER_CONSTANT >  {    return Math.exp(1.0);  }| t = < LARGEST_CLIQUE_SIZE >  {    return 1.0;  }| t = < CHROMATIC_NUMBER >  {    return 1.0;  }| t = < NUMBER_OF_VERTICES >  {    return 1.0;  }| t = < NUMBER_OF_EDGES >  {    return 1.0;  }| t = < LARGEST_DEGREE_IDENTIFIER >  {    return 1.0;  }| t = < EIGENVALUE_IDENTIFIER >  {    return 1.0;  }| t = < IDENTIFIER_WITH_OVERLINE >  {    return 1.0;  }| t = < DBL_CONST >  {    return Double.parseDouble(t.image);  }| t = < INT_CONST >  {    return Double.parseDouble(t.image);  }| "(" value = expr() ")"  {    return value;  }| "{" value = expr() "}"  {    return value;  }}
